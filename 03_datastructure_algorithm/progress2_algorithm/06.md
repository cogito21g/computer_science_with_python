### 2. 정렬 알고리즘 - 병합 정렬 (Merge Sort)

#### 이론
**병합 정렬 (Merge Sort)**: 병합 정렬은 분할 정복 알고리즘의 일종으로, 배열을 작은 부분 배열로 분할한 후 정렬된 부분 배열을 병합하여 전체 배열을 정렬합니다.
- **동작 과정**:
  1. 배열을 반으로 나눕니다.
  2. 나눈 각 부분 배열에 대해 재귀적으로 병합 정렬을 적용합니다.
  3. 정렬된 부분 배열을 병합하여 하나의 정렬된 배열로 만듭니다.
- **시간복잡도**: O(n log n)
- **공간복잡도**: O(n) (추가적인 배열을 사용)

#### 동작 과정
예를 들어, 배열 [12, 11, 13, 5, 6, 7]이 주어졌을 때 병합 정렬의 동작 과정은 다음과 같습니다.

1. **분할**:
   - 배열을 반으로 나눕니다: [12, 11, 13]와 [5, 6, 7]

2. **재귀적으로 분할**:
   - 첫 번째 부분 배열 [12, 11, 13]을 다시 나눕니다: [12]와 [11, 13]
   - 두 번째 부분 배열 [5, 6, 7]을 다시 나눕니다: [5]와 [6, 7]

3. **기본 단계 도달**:
   - 부분 배열 [11, 13]을 나눕니다: [11]과 [13]
   - 부분 배열 [6, 7]을 나눕니다: [6]과 [7]

4. **병합**:
   - 나뉜 부분 배열을 병합하여 정렬합니다:
     - [11]과 [13]을 병합: [11, 13]
     - [6]과 [7]을 병합: [6, 7]
     - [12]와 [11, 13]을 병합: [11, 12, 13]
     - [5]와 [6, 7]을 병합: [5, 6, 7]
     - 최종적으로 [11, 12, 13]과 [5, 6, 7]을 병합: [5, 6, 7, 11, 12, 13]

#### 구현
병합 정렬 알고리즘을 Python으로 구현해보겠습니다.

```python
def merge_sort(arr):
    if len(arr) <= 1:
        return arr  # 배열의 길이가 1 이하인 경우 이미 정렬된 상태입니다.

    mid = len(arr) // 2  # 배열을 반으로 나눌 중간 인덱스를 계산합니다.
    left_half = merge_sort(arr[:mid])  # 왼쪽 부분 배열을 재귀적으로 정렬합니다.
    right_half = merge_sort(arr[mid:])  # 오른쪽 부분 배열을 재귀적으로 정렬합니다.

    return merge(left_half, right_half)  # 정렬된 두 부분 배열을 병합합니다.

def merge(left, right):
    result = []  # 병합된 배열을 저장할 리스트를 초기화합니다.
    i = j = 0

    # 두 부분 배열을 비교하면서 병합합니다.
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1

    # 남아있는 요소들을 결과 배열에 추가합니다.
    result.extend(left[i:])
    result.extend(right[j:])
    
    return result

# 예시 배열
arr = [12, 11, 13, 5, 6, 7]
sorted_arr = merge_sort(arr)
print("Sorted array:", sorted_arr)
```

#### 실습
다음 코드를 직접 실행해보고, 다른 예시 배열에 대해서도 테스트해 보세요.

```python
arr = [38, 27, 43, 3, 9, 82, 10]
sorted_arr = merge_sort(arr)
print("Sorted array:", sorted_arr)
```
