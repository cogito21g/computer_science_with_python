### 2. 정렬 알고리즘 - 퀵 정렬 (Quick Sort)

#### 이론
**퀵 정렬 (Quick Sort)**: 퀵 정렬은 분할 정복 알고리즘의 일종으로, 배열을 정렬할 때 매우 효율적입니다.
- **동작 과정**:
  1. 배열에서 피벗(pivot) 요소를 선택합니다.
  2. 피벗을 기준으로 배열을 분할하여, 피벗보다 작은 요소들은 왼쪽에, 큰 요소들은 오른쪽에 위치시킵니다.
  3. 분할된 부분 배열에 대해 재귀적으로 퀵 정렬을 적용합니다.
  4. 재귀 호출이 종료되면 배열이 정렬된 상태가 됩니다.
- **시간복잡도**: 평균 O(n log n), 최악 O(n^2)
- **공간복잡도**: O(log n) (재귀 호출의 깊이)

#### 동작 과정
예를 들어, 배열 [10, 7, 8, 9, 1, 5]이 주어졌을 때 퀵 정렬의 동작 과정은 다음과 같습니다.

1. **첫 번째 분할**:
   - 피벗으로 배열의 마지막 요소 5를 선택합니다.
   - 5보다 작은 요소들은 왼쪽, 큰 요소들은 오른쪽으로 이동합니다.
   - 분할 후 배열: [1, 5, 8, 9, 10, 7]

2. **두 번째 분할 (왼쪽 부분 배열)**:
   - 부분 배열 [1]은 이미 정렬되어 있습니다.

3. **두 번째 분할 (오른쪽 부분 배열)**:
   - 피벗으로 7을 선택합니다.
   - 7보다 작은 요소들은 왼쪽, 큰 요소들은 오른쪽으로 이동합니다.
   - 분할 후 배열: [1, 5, 7, 9, 10, 8]

4. **세 번째 분할 (오른쪽 부분 배열의 왼쪽 부분)**:
   - 피벗으로 8을 선택합니다.
   - 8보다 작은 요소들은 왼쪽, 큰 요소들은 오른쪽으로 이동합니다.
   - 분할 후 배열: [1, 5, 7, 8, 10, 9]

5. **네 번째 분할 (오른쪽 부분 배열의 오른쪽 부분)**:
   - 부분 배열 [10, 9]에서 피벗 9를 선택합니다.
   - 분할 후 배열: [1, 5, 7, 8, 9, 10]

최종적으로 배열은 정렬된 상태가 됩니다.

#### 구현
퀵 정렬 알고리즘을 Python으로 구현해보겠습니다.

```python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr  # 배열의 길이가 1 이하인 경우 이미 정렬된 상태입니다.
    
    pivot = arr[len(arr) // 2]  # 피벗을 배열의 중간 요소로 선택합니다.
    left = [x for x in arr if x < pivot]  # 피벗보다 작은 요소들로 이루어진 배열.
    middle = [x for x in arr if x == pivot]  # 피벗과 같은 값들로 이루어진 배열.
    right = [x for x in arr if x > pivot]  # 피벗보다 큰 요소들로 이루어진 배열.
    
    return quick_sort(left) + middle + quick_sort(right)  # 재귀적으로 정렬하여 병합합니다.

# 예시 배열
arr = [10, 7, 8, 9, 1, 5]
sorted_arr = quick_sort(arr)
print("Sorted array:", sorted_arr)
```

#### 실습
다음 코드를 직접 실행해보고, 다른 예시 배열에 대해서도 테스트해 보세요.

```python
arr = [3, 6, 8, 10, 1, 2, 1]
sorted_arr = quick_sort(arr)
print("Sorted array:", sorted_arr)
```
